import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as e,o as t,c as p,a as n,b as l,d as o,e as i}from"./app-TdR3A7lU.js";const c={},u=i(`<h2 id="_1、双重检查的单例模式是否真的线程安全" tabindex="-1"><a class="header-anchor" href="#_1、双重检查的单例模式是否真的线程安全"><span>1、双重检查的单例模式是否真的线程安全？</span></a></h2><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Single</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Single</span> single<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">Single</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>

    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Single</span> getSingle<span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>single <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token class-name">Single</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>single <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                    single <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Single</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> single<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_2、问题剖析" tabindex="-1"><a class="header-anchor" href="#_2、问题剖析"><span>2、问题剖析</span></a></h2><p>在java中使用new关键字创建对象时，虚拟机会执行以下操作（并不完整，比如若new指令执行发现类还未加载，会触发类加载）：</p><ol><li>在堆上给对象分配内存</li><li>为内存空间初始化零值</li><li>调用&lt;init&gt;方法初始化</li><li>把对象引用返回给变量single，single不再是null</li></ol><p>而实际情况，是为了提升执行效率，cpu指令会重排序，变成了：</p><ol><li>在堆上给对象分配内存</li><li>把对象引用返回给变量single，single不再是null</li><li>为内存空间初始化零值</li><li>调用&lt;init&gt;方法初始化</li></ol><p>假设场景如下： 有两个线程A、B，同时调用getSingle,A先抢到cpu执行权，执行了new指令，此时分配了内存，并且把内存地址返回给了single变量，还没来得及初始化，而此时B也进入getSingle方法，判断第一个if条件，得到的single不是null,就直接返回了single,这就会有问题，因为这个single所指向的地址是一个还未初始化的，有可能甚至连零值都还没来得及填充，这里就出现了bug，这就是以上双重检查存在的问题。</p><blockquote><p>提到volatile总会说道主内存和工作内存，如何理解主内存和工作内存？ 主内存就是物理内存（不仅仅是堆或栈），工作内存就是cpu实际处理指令时工作的地方，也就是cpu缓存</p></blockquote><p>以上问题的根本原因，就是一个线程看到了另一个线程未正确初始化的对象。解决这个问题就要用到volatile关键字，此关键字特性：</p><ol><li>有序性</li><li>可见性</li></ol><p>有序性，synchronized保证代码有序，而使用volatile修饰的变量会禁止指令重排，保证的是指令有序，禁止single变量提前获取到对象引用； 可见性，不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</p><h3 id="_2-1-另一个例子" tabindex="-1"><a class="header-anchor" href="#_2-1-另一个例子"><span>2.1 另一个例子</span></a></h3><p>1.volatile关键字的两层语义</p><p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p><p>1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</p><p>2）禁止进行指令重排序。</p><p>先看一段代码，假如线程1先执行，线程2后执行：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">//线程1</span>
<span class="token keyword">boolean</span> stop <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stop<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//线程2</span>
stop <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。</p><p>下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。</p><p>那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。</p><p>但是用volatile修饰之后就变得不一样了：</p><p>第一：使用volatile关键字会强制将修改的值立即写入主存；</p><p>第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；</p><p>第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。</p><p>那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。</p><p>那么线程1读取到的就是最新的正确的值。</p><h2 id="_3、正确的双重检查单例模式写法" tabindex="-1"><a class="header-anchor" href="#_3、正确的双重检查单例模式写法"><span>3、正确的双重检查单例模式写法</span></a></h2><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Single</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token class-name">Single</span> single<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">Single</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>

    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Single</span> getSingle<span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>single <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token class-name">Single</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>single <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                    single <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Single</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> single<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_4、参考" tabindex="-1"><a class="header-anchor" href="#_4、参考"><span>4、参考</span></a></h2>`,31),r={href:"https://www.cnblogs.com/dolphin0520/p/3920373.html",target:"_blank",rel:"noopener noreferrer"};function d(k,v){const s=e("ExternalLinkIcon");return t(),p("div",null,[u,n("p",null,[n("a",r,[l("Java并发编程之volatile关键字"),o(s)])])])}const b=a(c,[["render",d],["__file","volatile.html.vue"]]),h=JSON.parse('{"path":"/java/jvm/volatile.html","title":"volatile关键字","lang":"zh-CN","frontmatter":{"title":"volatile关键字","date":"2023-02-01T00:00:00.000Z","description":"1、双重检查的单例模式是否真的线程安全？ 2、问题剖析 在java中使用new关键字创建对象时，虚拟机会执行以下操作（并不完整，比如若new指令执行发现类还未加载，会触发类加载）： 在堆上给对象分配内存 为内存空间初始化零值 调用<init>方法初始化 把对象引用返回给变量single，single不再是null 而实际情况，是为了提升执行效率，cpu...","head":[["meta",{"property":"og:url","content":"https://ChenSino.github.io/java/jvm/volatile.html"}],["meta",{"property":"og:site_name","content":"ChenSino"}],["meta",{"property":"og:title","content":"volatile关键字"}],["meta",{"property":"og:description","content":"1、双重检查的单例模式是否真的线程安全？ 2、问题剖析 在java中使用new关键字创建对象时，虚拟机会执行以下操作（并不完整，比如若new指令执行发现类还未加载，会触发类加载）： 在堆上给对象分配内存 为内存空间初始化零值 调用<init>方法初始化 把对象引用返回给变量single，single不再是null 而实际情况，是为了提升执行效率，cpu..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-22T03:45:12.000Z"}],["meta",{"property":"article:author","content":"ChenSino"}],["meta",{"property":"article:published_time","content":"2023-02-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-03-22T03:45:12.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"volatile关键字\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-02-01T00:00:00.000Z\\",\\"dateModified\\":\\"2024-03-22T03:45:12.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"ChenSino\\",\\"url\\":\\"https://ChenSino.github.io\\"}]}"]]},"headers":[{"level":2,"title":"1、双重检查的单例模式是否真的线程安全？","slug":"_1、双重检查的单例模式是否真的线程安全","link":"#_1、双重检查的单例模式是否真的线程安全","children":[]},{"level":2,"title":"2、问题剖析","slug":"_2、问题剖析","link":"#_2、问题剖析","children":[{"level":3,"title":"2.1 另一个例子","slug":"_2-1-另一个例子","link":"#_2-1-另一个例子","children":[]}]},{"level":2,"title":"3、正确的双重检查单例模式写法","slug":"_3、正确的双重检查单例模式写法","link":"#_3、正确的双重检查单例模式写法","children":[]},{"level":2,"title":"4、参考","slug":"_4、参考","link":"#_4、参考","children":[]}],"git":{"createdTime":1675240920000,"updatedTime":1711079112000,"contributors":[{"name":"ChenSino","email":"462488588@qq.com","commits":1},{"name":"ChenSino","email":"chenxk@sonoscape.net","commits":1}]},"readingTime":{"minutes":4.63,"words":1390},"filePathRelative":"java/jvm/volatile.md","localizedDate":"2023年2月1日","excerpt":"<h2>1、双重检查的单例模式是否真的线程安全？</h2>\\n<div class=\\"language-java\\" data-ext=\\"java\\" data-title=\\"java\\"><pre class=\\"language-java\\"><code><span class=\\"token keyword\\">public</span> <span class=\\"token keyword\\">class</span> <span class=\\"token class-name\\">Single</span><span class=\\"token punctuation\\">{</span>\\n    <span class=\\"token keyword\\">public</span> <span class=\\"token keyword\\">static</span> <span class=\\"token class-name\\">Single</span> single<span class=\\"token punctuation\\">;</span>\\n\\n    <span class=\\"token keyword\\">private</span> <span class=\\"token class-name\\">Single</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">{</span>\\n\\n    <span class=\\"token punctuation\\">}</span>\\n\\n    <span class=\\"token keyword\\">public</span> <span class=\\"token keyword\\">static</span> <span class=\\"token class-name\\">Single</span> getSingle<span class=\\"token punctuation\\">{</span>\\n        <span class=\\"token keyword\\">if</span><span class=\\"token punctuation\\">(</span>single <span class=\\"token operator\\">==</span> <span class=\\"token keyword\\">null</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">{</span>\\n            <span class=\\"token keyword\\">synchronized</span><span class=\\"token punctuation\\">(</span><span class=\\"token class-name\\">Single</span><span class=\\"token punctuation\\">.</span><span class=\\"token keyword\\">class</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">{</span>\\n                <span class=\\"token keyword\\">if</span><span class=\\"token punctuation\\">(</span>single <span class=\\"token operator\\">==</span> <span class=\\"token keyword\\">null</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">{</span>\\n                    single <span class=\\"token operator\\">=</span> <span class=\\"token keyword\\">new</span> <span class=\\"token class-name\\">Single</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n                <span class=\\"token punctuation\\">}</span>\\n            <span class=\\"token punctuation\\">}</span>\\n        <span class=\\"token punctuation\\">}</span>\\n        <span class=\\"token keyword\\">return</span> single<span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token punctuation\\">}</span>\\n<span class=\\"token punctuation\\">}</span>\\n</code></pre></div>","autoDesc":true}');export{b as comp,h as data};
