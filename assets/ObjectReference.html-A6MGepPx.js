import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as s,c as a,e}from"./app-Cs38sdJl.js";const t={},p=e(`<h2 id="_1、强引用" tabindex="-1"><a class="header-anchor" href="#_1、强引用"><span>1、强引用</span></a></h2><pre><code>StrongReference，java中默认的引用类型都是强引用，比如\`Objectg obj = new Object()\`，这个obj就是强引用。强引用的特性是只要引用存在，被引用的对象就不会被垃圾回收器回收，这个比较简单，不做测试。
</code></pre><h2 id="_2、软引用" tabindex="-1"><a class="header-anchor" href="#_2、软引用"><span>2、软引用</span></a></h2><p>SoftReference，软引用代码比较简单，直接调用其构造函数即可构造一个软引用对象。软引用的特性是只要虚拟机内存够用，则这个对象会 一直存在，不会被垃圾回收器回收，当内存不够时会触发垃圾回收，当回收后内存够用则不会回收软引用的对象，当执行了一次回收后内存依然不够才会考虑回收软引用的对象。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>    <span class="token doc-comment comment">/**
     * 堆内存分配30m,默认情况老年代和新生代2:1,eden和survivor是8:1,因此老年代是
     * 20m,新生代10m，其中eden是8m,suvivor是1m,因此新生代总共8+1=9m,还有1m是浪* 费的
     * -XX:+PrintGCDetails -Xmx30m -Xms30m -Xmn10m
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
        <span class="token comment">//建立一个5m的对象，大对象直接进入老年代</span>
        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token constant">DATA_5M</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">5</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token class-name">SoftReference</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> softReference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token constant">DATA_5M</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token constant">DATA_5M</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如下日志可以看到最终老年代有26%的内存占用，差不多刚好5m,就是大对象，说明当内存足够时，软件用的对象不会被回收。 <img src="https://afatpig.oss-cn-chengdu.aliyuncs.com/blog/20230131112235.png" alt="20230131112235"></p><p>继续测试，当内存不够时，软引用对象会被回收掉</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>   <span class="token doc-comment comment">/**
     * -XX:+PrintGCDetails -Xmx30m -Xms30m -Xmn10m
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
        <span class="token comment">//建立一个5m的对象，大对象直接进入老年代</span>
        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token constant">DATA_5M</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">5</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token class-name">SoftReference</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> softReference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token constant">DATA_5M</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token constant">DATA_5M</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token comment">//再创建一个大对象，让老年代内存不够容纳此对象从而触发垃圾回收</span>
        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token constant">DATA_15M</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">15</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下图可以清晰看到，最终老年代有75%占用，差不多刚好15m,就是后来创建的大对象，说明之前那个被回收了 <img src="https://afatpig.oss-cn-chengdu.aliyuncs.com/blog/20230131112554.png" alt="20230131112554"></p><h2 id="_3、弱引用" tabindex="-1"><a class="header-anchor" href="#_3、弱引用"><span>3、弱引用</span></a></h2><p>WeakReference,下次垃圾回收时，弱引用的对象一定会被回收</p><h2 id="_4、虚引用" tabindex="-1"><a class="header-anchor" href="#_4、虚引用"><span>4、虚引用</span></a></h2>`,12),o=[p];function c(l,i){return s(),a("div",null,o)}const d=n(t,[["render",c],["__file","ObjectReference.html.vue"]]),k=JSON.parse('{"path":"/java/jvm/ObjectReference.html","title":"对象引用类型","lang":"zh-CN","frontmatter":{"title":"对象引用类型","date":"2023-01-31T00:00:00.000Z","description":"1、强引用 2、软引用 SoftReference，软引用代码比较简单，直接调用其构造函数即可构造一个软引用对象。软引用的特性是只要虚拟机内存够用，则这个对象会 一直存在，不会被垃圾回收器回收，当内存不够时会触发垃圾回收，当回收后内存够用则不会回收软引用的对象，当执行了一次回收后内存依然不够才会考虑回收软引用的对象。 如下日志可以看到最终老年代有26%...","head":[["meta",{"property":"og:url","content":"https://ChenSino.github.io/java/jvm/ObjectReference.html"}],["meta",{"property":"og:site_name","content":"ChenSino"}],["meta",{"property":"og:title","content":"对象引用类型"}],["meta",{"property":"og:description","content":"1、强引用 2、软引用 SoftReference，软引用代码比较简单，直接调用其构造函数即可构造一个软引用对象。软引用的特性是只要虚拟机内存够用，则这个对象会 一直存在，不会被垃圾回收器回收，当内存不够时会触发垃圾回收，当回收后内存够用则不会回收软引用的对象，当执行了一次回收后内存依然不够才会考虑回收软引用的对象。 如下日志可以看到最终老年代有26%..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://afatpig.oss-cn-chengdu.aliyuncs.com/blog/20230131112235.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-02-01T08:42:00.000Z"}],["meta",{"property":"article:author","content":"ChenSino"}],["meta",{"property":"article:published_time","content":"2023-01-31T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-02-01T08:42:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"对象引用类型\\",\\"image\\":[\\"https://afatpig.oss-cn-chengdu.aliyuncs.com/blog/20230131112235.png\\",\\"https://afatpig.oss-cn-chengdu.aliyuncs.com/blog/20230131112554.png\\"],\\"datePublished\\":\\"2023-01-31T00:00:00.000Z\\",\\"dateModified\\":\\"2023-02-01T08:42:00.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"ChenSino\\",\\"url\\":\\"https://ChenSino.github.io\\"}]}"]]},"headers":[{"level":2,"title":"1、强引用","slug":"_1、强引用","link":"#_1、强引用","children":[]},{"level":2,"title":"2、软引用","slug":"_2、软引用","link":"#_2、软引用","children":[]},{"level":2,"title":"3、弱引用","slug":"_3、弱引用","link":"#_3、弱引用","children":[]},{"level":2,"title":"4、虚引用","slug":"_4、虚引用","link":"#_4、虚引用","children":[]}],"git":{"createdTime":1675240920000,"updatedTime":1675240920000,"contributors":[{"name":"ChenSino","email":"chenxk@sonoscape.net","commits":1}]},"readingTime":{"minutes":1.88,"words":565},"filePathRelative":"java/jvm/ObjectReference.md","localizedDate":"2023年1月31日","excerpt":"<h2>1、强引用</h2>\\n<pre><code>StrongReference，java中默认的引用类型都是强引用，比如`Objectg obj = new Object()`，这个obj就是强引用。强引用的特性是只要引用存在，被引用的对象就不会被垃圾回收器回收，这个比较简单，不做测试。\\n</code></pre>\\n<h2>2、软引用</h2>\\n<p>SoftReference，软引用代码比较简单，直接调用其构造函数即可构造一个软引用对象。软引用的特性是只要虚拟机内存够用，则这个对象会 一直存在，不会被垃圾回收器回收，当内存不够时会触发垃圾回收，当回收后内存够用则不会回收软引用的对象，当执行了一次回收后内存依然不够才会考虑回收软引用的对象。</p>","autoDesc":true}');export{d as comp,k as data};
