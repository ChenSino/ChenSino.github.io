import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as s,c as a,e}from"./app-Cf-knFG-.js";const t={},p=e(`<p>[TOC]</p><h3 id="_1-spring生命周期" tabindex="-1"><a class="header-anchor" href="#_1-spring生命周期"><span>1. spring生命周期</span></a></h3><p>spring容器实例化一个对象往大说主要是分为两步</p><h4 id="_1-1-第一步-根据配置生成beandefinition" tabindex="-1"><a class="header-anchor" href="#_1-1-第一步-根据配置生成beandefinition"><span>1.1 第一步：根据配置生成BeanDefinition</span></a></h4><p>根据配置文件（properties、xml）、注解等生成Bean的定义，BeanDefinition的作用是用来描述如何生成真正的对象，对象的生成是通过反射实现，这里的关键词是“描述”，它的作用是告诉容器如何去生成一个真正的对象，它不是真正的对象！！！！</p><p>BeanDefinition里包含信息如下：</p><ol><li>class：有了bean的class用反射就可以创建出一个真正的对象；</li><li>scope ：可取singleton、prototype，即单例还是多例；</li><li>lazyInit：表明此bean是否为懒加载，如果是true代表容器启动后自动创建出bean真实对象，若为false，则代表需要显示的调用容器的getBean()方法时才会实例化出对象；</li><li>其它字段不再介绍</li></ol><h4 id="_1-2-第二步-根据beandefinition来生成真正的对象" tabindex="-1"><a class="header-anchor" href="#_1-2-第二步-根据beandefinition来生成真正的对象"><span>1.2 第二步：根据BeanDefinition来生成真正的对象</span></a></h4><p><img src="https://afatpig.oss-cn-chengdu.aliyuncs.com/blog/image-20210526182642991.png" alt="image-20210526182642991"></p><h3 id="_2-扩展点介绍" tabindex="-1"><a class="header-anchor" href="#_2-扩展点介绍"><span>2. 扩展点介绍</span></a></h3><h4 id="_2-1-扩展点1-beanfactorypostprocessor" tabindex="-1"><a class="header-anchor" href="#_2-1-扩展点1-beanfactorypostprocessor"><span>2.1 扩展点1-BeanFactoryPostProcessor</span></a></h4><p>此接口在容器启动后，并且BeanDefinition已经注册到容器中以后，调用其回调函数，作用就是能拿到ConfigurableListableBeanFactory，然后操作里面的容器里面的BeanDefinition</p><p>前面说了第一步是生成BeanDefinition此时真实的对象还未生成，所以可以用spring预留的扩展接口做一些事情，比如在代码中修改一个bean的BeanDefinition</p><p>举例说明（此场景可能没啥卵用，只是为了证明可以在实例化出对象之前可以修改它的BeanDefinition）：</p><p>第一次测试：在xml随便配一个bean，bean标签有个lazyInit，默认是false</p><div class="language-xml line-numbers-mode" data-ext="xml" data-title="xml"><pre class="language-xml"><code>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>address<span class="token punctuation">&quot;</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>com.chen.bean.Address<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>addressName<span class="token punctuation">&quot;</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>startName<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第二次测试：在实例化之前通过扩展点的功能把lazyInit改为true</p><p>实现方式：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyBeanFactoryPostProccessor</span> <span class="token keyword">implements</span> <span class="token class-name">BeanFactoryPostProcessor</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">postProcessBeanFactory</span><span class="token punctuation">(</span><span class="token class-name">ConfigurableListableBeanFactory</span> beanFactory<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">{</span>
        <span class="token comment">//获取名字为address的BeanDefinition</span>
        <span class="token class-name">BeanDefinition</span> address <span class="token operator">=</span> beanFactory<span class="token punctuation">.</span><span class="token function">getBeanDefinition</span><span class="token punctuation">(</span><span class="token string">&quot;address&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//把它改成懒加载</span>
        address<span class="token punctuation">.</span><span class="token function">setLazyInit</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>入口函数，注意此处我没有调用applicationContext.getBean(&quot;address&quot;)，如果我们主动去获取address就不能达到测试效果，主动调用的话会导致address这个bean的lazyInit失效</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>   <span class="token annotation punctuation">@Test</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token class-name">ApplicationContext</span> applicationContext <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">&quot;applicationContext-dog.xml&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2-2-扩展点2-beanpostprocessor" tabindex="-1"><a class="header-anchor" href="#_2-2-扩展点2-beanpostprocessor"><span>2.2 扩展点2-BeanPostProcessor</span></a></h4><h5 id="_2-2-1-继续上面的实验" tabindex="-1"><a class="header-anchor" href="#_2-2-1-继续上面的实验"><span>2.2.1 继续上面的实验</span></a></h5><p>通过以上代码修改后会发现容器启动后第一次有实例化一个Address对象，第二次并没有实例化Address对象。如何证明呢？这就要用到另一个扩展点BeanPostProcessor</p><p>创建一个bean，并且让其实现BeanPostProcessor接口，该接口的作用就是在容器实例化出一个bean（真实的对象，要和BeanDefinition区分）后，会自动调用以下两个前置和后置函数，通过观察可以发现在2.1的测试中，第一次打印除了beanName是address的，第二次没打印出来，说明第二次没有实例化address</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyBeanPostProccessor</span> <span class="token keyword">implements</span> <span class="token class-name">BeanPostProcessor</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">postProcessBeforeInitialization</span><span class="token punctuation">(</span><span class="token class-name">Object</span> bean<span class="token punctuation">,</span> <span class="token class-name">String</span> beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;postProcessBeforeInitialization====&gt;&quot;</span> <span class="token operator">+</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> bean<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">postProcessAfterInitialization</span><span class="token punctuation">(</span><span class="token class-name">Object</span> bean<span class="token punctuation">,</span> <span class="token class-name">String</span> beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;postProcessAfterInitialization======&gt;&quot;</span><span class="token operator">+</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> bean<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="_2-2-2-beanpostprocessor扩展点的其它作用" tabindex="-1"><a class="header-anchor" href="#_2-2-2-beanpostprocessor扩展点的其它作用"><span>2.2.2 BeanPostProcessor扩展点的其它作用</span></a></h5><p>BeanPostProcessor这个扩展点可以在容器创建一个对象后继续修改这个对象的属性值，比如你在xml中配置address后，给他的addressName字段设置了一个值，然后你是可以在BeanPostProcessor接口中去修改这个addressName这个字段的，并且修改了以后，你通过容器的getBean方法获取的对象是你修改后的。修改下MyBeanPostProccessor</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyBeanPostProccessor</span> <span class="token keyword">implements</span> <span class="token class-name">BeanPostProcessor</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">postProcessBeforeInitialization</span><span class="token punctuation">(</span><span class="token class-name">Object</span> bean<span class="token punctuation">,</span> <span class="token class-name">String</span> beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;postProcessBeforeInitialization====&gt;&quot;</span> <span class="token operator">+</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>bean<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//因为每个bean的实例化都会触发此接口的前置以及后置方法，我们只想修改address这个bean，所以要判断一下</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>beanName<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">&quot;address&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">Address</span> address <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Address</span><span class="token punctuation">)</span> bean<span class="token punctuation">;</span>
            address<span class="token punctuation">.</span><span class="token function">setAddressName</span><span class="token punctuation">(</span><span class="token string">&quot;随便一个地址名字&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> bean<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">postProcessAfterInitialization</span><span class="token punctuation">(</span><span class="token class-name">Object</span> bean<span class="token punctuation">,</span> <span class="token class-name">String</span> beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;postProcessAfterInitialization======&gt;&quot;</span><span class="token operator">+</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> bean<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过以上代码修改address对象的属性后，再通过getBean方法获取对象，会发现对象的值是我们修改后的，而非xml中定义的那个值</p><h4 id="_2-3-扩展点3-beannameaware" tabindex="-1"><a class="header-anchor" href="#_2-3-扩展点3-beannameaware"><span>2.3 扩展点3-BeanNameAware</span></a></h4><p>在BeanPostProcessor之前执行，获取Bean的名字</p>`,32),o=[p];function i(c,l){return s(),a("div",null,o)}const d=n(t,[["render",i],["__file","SpringExtensionPoint.html.vue"]]),k=JSON.parse('{"path":"/java/framework/spring/SpringExtensionPoint.html","title":"Spring框架扩展点","lang":"zh-CN","frontmatter":{"title":"Spring框架扩展点","date":"2018-05-21T00:00:00.000Z","description":"[TOC] 1. spring生命周期 spring容器实例化一个对象往大说主要是分为两步 1.1 第一步：根据配置生成BeanDefinition 根据配置文件（properties、xml）、注解等生成Bean的定义，BeanDefinition的作用是用来描述如何生成真正的对象，对象的生成是通过反射实现，这里的关键词是“描述”，它的作用是告诉容器...","head":[["meta",{"property":"og:url","content":"https://ChenSino.github.io/java/framework/spring/SpringExtensionPoint.html"}],["meta",{"property":"og:site_name","content":"ChenSino"}],["meta",{"property":"og:title","content":"Spring框架扩展点"}],["meta",{"property":"og:description","content":"[TOC] 1. spring生命周期 spring容器实例化一个对象往大说主要是分为两步 1.1 第一步：根据配置生成BeanDefinition 根据配置文件（properties、xml）、注解等生成Bean的定义，BeanDefinition的作用是用来描述如何生成真正的对象，对象的生成是通过反射实现，这里的关键词是“描述”，它的作用是告诉容器..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://afatpig.oss-cn-chengdu.aliyuncs.com/blog/image-20210526182642991.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2022-08-01T13:56:59.000Z"}],["meta",{"property":"article:author","content":"ChenSino"}],["meta",{"property":"article:published_time","content":"2018-05-21T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2022-08-01T13:56:59.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Spring框架扩展点\\",\\"image\\":[\\"https://afatpig.oss-cn-chengdu.aliyuncs.com/blog/image-20210526182642991.png\\"],\\"datePublished\\":\\"2018-05-21T00:00:00.000Z\\",\\"dateModified\\":\\"2022-08-01T13:56:59.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"ChenSino\\",\\"url\\":\\"https://ChenSino.github.io\\"}]}"]]},"headers":[{"level":3,"title":"1. spring生命周期","slug":"_1-spring生命周期","link":"#_1-spring生命周期","children":[]},{"level":3,"title":"2. 扩展点介绍","slug":"_2-扩展点介绍","link":"#_2-扩展点介绍","children":[]}],"git":{"createdTime":1659362219000,"updatedTime":1659362219000,"contributors":[{"name":"chenkun","email":"462488588@qq.com","commits":1}]},"readingTime":{"minutes":3.59,"words":1078},"filePathRelative":"java/framework/spring/SpringExtensionPoint.md","localizedDate":"2018年5月21日","excerpt":"<p>[TOC]</p>\\n<h3>1. spring生命周期</h3>\\n<p>spring容器实例化一个对象往大说主要是分为两步</p>\\n<h4>1.1 第一步：根据配置生成BeanDefinition</h4>\\n<p>根据配置文件（properties、xml）、注解等生成Bean的定义，BeanDefinition的作用是用来描述如何生成真正的对象，对象的生成是通过反射实现，这里的关键词是“描述”，它的作用是告诉容器如何去生成一个真正的对象，它不是真正的对象！！！！</p>\\n<p>BeanDefinition里包含信息如下：</p>\\n<ol>\\n<li>class：有了bean的class用反射就可以创建出一个真正的对象；</li>\\n<li>scope ：可取singleton、prototype，即单例还是多例；</li>\\n<li>lazyInit：表明此bean是否为懒加载，如果是true代表容器启动后自动创建出bean真实对象，若为false，则代表需要显示的调用容器的getBean()方法时才会实例化出对象；</li>\\n<li>其它字段不再介绍</li>\\n</ol>","autoDesc":true}');export{d as comp,k as data};
