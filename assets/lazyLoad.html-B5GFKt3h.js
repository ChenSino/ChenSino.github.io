import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as s,c as a,e as t}from"./app-xHrnIhLr.js";const e={},p=t(`<h3 id="一-为什么需要图片懒加载" tabindex="-1"><a class="header-anchor" href="#一-为什么需要图片懒加载"><span><strong>一，为什么需要图片懒加载</strong></span></a></h3><p>在老版本的Chrome中，图片的加载其实是会阻塞DOM渲染的。在我们现代浏览器中，这一点基本不用担心了，也就是说现在的图片加载不会阻塞DOM渲染，<strong>但是每一个图片都会对应一个HTTP请求</strong>，<strong>而浏览器允许同时并发请求的数量是有限的（数量为6）</strong>，假设你的网站有大量的图片，那么加载的过程是很耗时的，尤其像那些电商类需要大量图片的网站，可想而知，网站的初始加载时间会很长，再加上网络等其它影响，用户体验会很差。为了解决这个问题，提高用户体验，所以就出现了懒加载这种方式来减轻服务器的压力，优先加载可视区域的内容，其他部分等进入了可视区域再加载，从而提高性能。</p><h3 id="二-图片懒加载原理" tabindex="-1"><a class="header-anchor" href="#二-图片懒加载原理"><span><strong>二，图片懒加载原理</strong></span></a></h3><p>原理其实非常简单，主要就是需要判断元素是否进入了可视区，进入了可视区就去请求对应的图片，否则就显示一张兜底的占位图。</p><p>实现图片懒加载基本要点如下所示：</p><p><img src="https://afatpig.oss-cn-chengdu.aliyuncs.com/blog/图片懒加载.png" alt="img"></p><h3 id="三-实战" tabindex="-1"><a class="header-anchor" href="#三-实战"><span>三，实战</span></a></h3><p>3.1 常用:利用图片顶部距离小于浏览器可视区域的高度来判断是否加载图片</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">//获取图片元素</span>
<span class="token keyword">const</span> images <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">&#39;img&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//scroll滚动事件</span>
window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&#39;scroll&#39;</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
     <span class="token comment">//判断每张图片的位置是否出现在可视区域</span>
    images<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">image</span> <span class="token operator">=&gt;</span><span class="token punctuation">{</span>
        <span class="token comment">//获取每张图片到顶部的距离</span>
        <span class="token keyword">const</span> imTop <span class="token operator">=</span> image<span class="token punctuation">.</span><span class="token function">getBoundingClientRect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>top<span class="token punctuation">;</span>
         <span class="token keyword">const</span> imbottom <span class="token operator">=</span> image<span class="token punctuation">.</span><span class="token function">getBoundingClientRect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>bottom<span class="token punctuation">;</span>
        <span class="token comment">//当前元素顶部距离小于当前浏览器的可视高度并且元素距离底部距离大于等于0 ： 能够显示出来 可以加载</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>imTop<span class="token operator">&lt;</span>window<span class="token punctuation">.</span>innerHeight <span class="token operator">&amp;&amp;</span> imbottom<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token comment">//使用自定义属性data-src。在定义的时候：&lt;img data-src=&quot;图片资源路径&quot; &gt;</span>
            <span class="token keyword">const</span> data_src <span class="token operator">=</span> image<span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token string">&#39;data-src&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取自定义属性</span>
            image<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">&#39;src&#39;</span><span class="token punctuation">,</span>data_src<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//赋值给原本的的src属性，这样就显示了</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token comment">//即使图片加载了还是会不断触发事件，非常消耗资源</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;触发&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><strong>getBoundingClientRect</strong>返回值是一个DOMRect对象，这个对象是由该元素的getClientRects()方法返回的一组矩形的集合，就是该元素的 CSS 边框大小。返回的结果是包含完整元素的最小矩形，并且拥有left, top, right, bottom, x, y, width, 和 height这几个以像素为单位的只读属性用于描述整个边框。除了width 和 height 以外的属性是相对于视图窗口的左上角来计算的。</p></blockquote><p><img src="https://afatpig.oss-cn-chengdu.aliyuncs.com/blog/clipboard.png" alt="img"></p><p>3.2 优化：使用浏览器提供的构造函数IntersectionObserver。</p><blockquote><p><code>IntersectionObserver</code> 是一个新的 API，可以自动&quot;观察&quot;元素是否可见，Chrome 51+ 已经支持。由于可见（visible）的本质是，目标元素与视口产生一个交叉区，所以这个 API 叫做&quot;交叉观察器&quot;。</p></blockquote><p><code>let observer = new IntersectionObserver(callback, [options])</code></p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">//获取图片元素</span>
<span class="token keyword">const</span> images <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">&#39;img&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//定义callback函数  接受的参数是数组</span>
<span class="token keyword">const</span> <span class="token function-variable function">callback</span> <span class="token operator">=</span><span class="token punctuation">(</span><span class="token parameter">entries</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    entries<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">entry</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
        <span class="token comment">//isIntersecting属性为true时，说明到可视区域了 可以显示出来</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span>isIntersecting<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">//target属性 就是目标元素</span>
        <span class="token keyword">const</span> image <span class="token operator">=</span> entry<span class="token punctuation">.</span>target<span class="token punctuation">;</span>
        <span class="token keyword">const</span> data_src <span class="token operator">=</span> image<span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token string">&#39;data-src&#39;</span><span class="token punctuation">)</span>
        image<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">&#39;src&#39;</span><span class="token punctuation">,</span>data_src<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//显示出来后取消 观察 这个动作。不再观察了</span>
        obser<span class="token punctuation">.</span><span class="token function">unobserve</span><span class="token punctuation">(</span>image<span class="token punctuation">)</span><span class="token punctuation">;</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;触发&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">//回调函数callback一般触发两次 ,目标元素能看见 触发一次，目标元素看不见了 触发一次</span>
<span class="token keyword">const</span> obser <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IntersectionObserver</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
images<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">image</span> <span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    <span class="token comment">//xxx.observe(DOM节点)  观察每个img节点</span>
    obser<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span>image<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,15),o=[p];function c(i,l){return s(),a("div",null,o)}const d=n(e,[["render",c],["__file","lazyLoad.html.vue"]]),k=JSON.parse('{"path":"/frontweb/es5/lazyLoad.html","title":"图片懒加载","lang":"zh-CN","frontmatter":{"title":"图片懒加载","date":"2022-04-25T00:00:00.000Z","author":"qianxun","category":["js基础"],"tag":["必会"],"description":"一，为什么需要图片懒加载 在老版本的Chrome中，图片的加载其实是会阻塞DOM渲染的。在我们现代浏览器中，这一点基本不用担心了，也就是说现在的图片加载不会阻塞DOM渲染，但是每一个图片都会对应一个HTTP请求，而浏览器允许同时并发请求的数量是有限的（数量为6），假设你的网站有大量的图片，那么加载的过程是很耗时的，尤其像那些电商类需要大量图片的网站，可...","head":[["meta",{"property":"og:url","content":"https://ChenSino.github.io/frontweb/es5/lazyLoad.html"}],["meta",{"property":"og:site_name","content":"ChenSino"}],["meta",{"property":"og:title","content":"图片懒加载"}],["meta",{"property":"og:description","content":"一，为什么需要图片懒加载 在老版本的Chrome中，图片的加载其实是会阻塞DOM渲染的。在我们现代浏览器中，这一点基本不用担心了，也就是说现在的图片加载不会阻塞DOM渲染，但是每一个图片都会对应一个HTTP请求，而浏览器允许同时并发请求的数量是有限的（数量为6），假设你的网站有大量的图片，那么加载的过程是很耗时的，尤其像那些电商类需要大量图片的网站，可..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://afatpig.oss-cn-chengdu.aliyuncs.com/blog/图片懒加载.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2022-08-01T13:56:59.000Z"}],["meta",{"property":"article:author","content":"qianxun"}],["meta",{"property":"article:tag","content":"必会"}],["meta",{"property":"article:published_time","content":"2022-04-25T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2022-08-01T13:56:59.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"图片懒加载\\",\\"image\\":[\\"https://afatpig.oss-cn-chengdu.aliyuncs.com/blog/图片懒加载.png\\",\\"https://afatpig.oss-cn-chengdu.aliyuncs.com/blog/clipboard.png\\"],\\"datePublished\\":\\"2022-04-25T00:00:00.000Z\\",\\"dateModified\\":\\"2022-08-01T13:56:59.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"qianxun\\"}]}"]]},"headers":[{"level":3,"title":"一，为什么需要图片懒加载","slug":"一-为什么需要图片懒加载","link":"#一-为什么需要图片懒加载","children":[]},{"level":3,"title":"二，图片懒加载原理","slug":"二-图片懒加载原理","link":"#二-图片懒加载原理","children":[]},{"level":3,"title":"三，实战","slug":"三-实战","link":"#三-实战","children":[]}],"git":{"createdTime":1659362219000,"updatedTime":1659362219000,"contributors":[{"name":"chenkun","email":"462488588@qq.com","commits":1}]},"readingTime":{"minutes":3.17,"words":951},"filePathRelative":"frontweb/es5/lazyLoad.md","localizedDate":"2022年4月25日","excerpt":"<h3><strong>一，为什么需要图片懒加载</strong></h3>\\n<p>在老版本的Chrome中，图片的加载其实是会阻塞DOM渲染的。在我们现代浏览器中，这一点基本不用担心了，也就是说现在的图片加载不会阻塞DOM渲染，<strong>但是每一个图片都会对应一个HTTP请求</strong>，<strong>而浏览器允许同时并发请求的数量是有限的（数量为6）</strong>，假设你的网站有大量的图片，那么加载的过程是很耗时的，尤其像那些电商类需要大量图片的网站，可想而知，网站的初始加载时间会很长，再加上网络等其它影响，用户体验会很差。为了解决这个问题，提高用户体验，所以就出现了懒加载这种方式来减轻服务器的压力，优先加载可视区域的内容，其他部分等进入了可视区域再加载，从而提高性能。</p>","autoDesc":true}');export{d as comp,k as data};
