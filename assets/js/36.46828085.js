(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{566:function(a,s,t){"use strict";t.r(s);var e=t(10),r=function(a){a.options.__data__block__={mermaid_382ee14d:"graph LR;\nA[Custom ClassLoader]--\x3eB[Application classloader]--\x3eC[Extension classloader]--\x3e d[Bootstrap class loader]\n"}},o=Object(e.a)({},(function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("p",[a._v("为什么说spi打破了双亲委派机制？\n")]),a._v(" "),t("h1",{attrs:{id:"_1、什么是双亲委派"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、什么是双亲委派"}},[a._v("#")]),a._v(" 1、什么是双亲委派？")]),a._v(" "),t("h1",{attrs:{id:"_2、什么是spi"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、什么是spi"}},[a._v("#")]),a._v(" 2、什么是SPI")]),a._v(" "),t("h1",{attrs:{id:"_3、为什么spi打破了双亲委派"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3、为什么spi打破了双亲委派"}},[a._v("#")]),a._v(" 3、为什么SPI打破了双亲委派")]),a._v(" "),t("h2",{attrs:{id:"_3-1-contextclassloader"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-contextclassloader"}},[a._v("#")]),a._v(" 3.1 ContextClassLoader")]),a._v(" "),t("p",[a._v("Thread context class loader存在的目的主要是为了解决parent delegation机制下无法干净的解决的问题。假如有下述委派链：")]),a._v(" "),t("Mermaid",{attrs:{id:"mermaid_382ee14d",graph:a.$dataBlock.mermaid_382ee14d}}),t("p",[a._v("那么委派链左边的ClassLoader就可以很自然的使用右边的ClassLoader所加载的类。")]),a._v(" "),t("p",[a._v("但如果情况要反过来，是右边的ClassLoader所加载的代码需要反过来去找委派链靠左边的ClassLoader去加载东西怎么办呢？没辙，parent delegation是单向的，没办法反过来从右边找左边.")]),a._v(" "),t("p",[a._v("就是说当我们this.getClass().getClassLoader();可以获取到所有已经加载过的文件,\n但是Application class loader -> Extension class loader -> Bootstrap class loader 就获取不到Custom ClassLoader 能加载到的信息,那么怎么办呢? 于是,Thread就把当前的类加载器,给保存下来了,其他加载器,需要的时候,就把当前线程的加载器,获取到.")])],1)}),[],!1,null,null,null);"function"==typeof r&&r(o);s.default=o.exports}}]);